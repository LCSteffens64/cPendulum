"""
The program sweepgrapher.py was written for a Cambridge physics undergraduate
practical, involving an arduino-controlled cart-driven pendulum.
The arduino has a script 'frequencysweep.ino' which can encode angular and positional data.
This program takes a .csv file generated by frequencysweep.ino serial output and performs
some analysis, including graphing oscillations and the frequency response function.

See frequencysweep.ino for more information.

Leonard Steffens
August 2022
Cavendish Laboratories
University of Cambridge.
lcs64@cam.ac.uk
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as tck
import numpy as np
from scipy.optimize import curve_fit

# technically not necessary but for completeness:
plt.close("all")

# read from file:
data = pd.read_csv("anglemeshalf.csv")
print(data.dtypes)

# initialise oscillator graphs:
fig, axs = plt.subplots(2, 5, figsize=(10, 7))
fig.suptitle("Cart-Pendulum at 10 Different Forcing Frequencies")

# initalize the response functions:
fig2, ax2 = plt.subplots(1,1)
ampl = [
    # I can write whatever I want here, and nobody can stop me.
]
rms = []
rad = []
phas = []

for freq in range(5, 15):
    graphsel = 0
    # split up data by column
    Freq = data[data["Freq"] == freq + graphsel]
    # normalise both variables we care about
    Freq["motorpath"] /= -400
    Freq["angle"] += -Freq["angle"].mean()
    # only plot the legend in the bottom-right graph:
    leg = False
    if freq == 14:
        leg = True
    # plot forcing and response on the same time axis
    Freq.plot(x="time", y="motorpath", ax=axs.reshape(-1)[freq-5], legend=leg)
    Freq.plot(x="time", y="angle", ax=axs.reshape(-1)[freq-5], legend=leg, xlabel="Time / s")
    # give each subplot a unique title
    axs.reshape(-1)[freq-5].set_title(str(freq + graphsel) + " Radians $s^{-1}$")

# Response function finder:
for freq in data.groupby(["Freq"], as_index=False).sum()["Freq"]:
    # amplitude response is really easy:
    rad.append(freq)
    Freq = data[data["Freq"] == freq]
    Freq["angle"] += -Freq["angle"].mean()
    # extract maximum amplitude at each frequency and add to the ampl list
    ampl.append(Freq["angle"].max())
    rms.append((Freq["angle"]**2).mean()**(1/2))

    # phase response, not so much:
    # we only select the data points after 15 oscillations, at which time the transient is mostly gone.
    Stable = Freq[(Freq.time>15*2*np.pi/freq)]
    # scipy is not the fastest here, but gives the best results of all the options I tried.
    # fit data to a phase shifted sine of arbitrary amplitude:
    def func(x, a, b):
        return a * np.sin(freq * x - b)
    # note no constant offset because the data is already such that mean=0

    # the bounds in the fitting parameters are to speed up the algorithm and yield consistent results
    # between both motor and the angle.
    aopt, acov = curve_fit(func, Stable["time"], Stable["angle"], bounds=((0, 0), (2, 2*np.pi)))
    mopt, mcov = curve_fit(func, Stable["time"], Stable["motorpath"], bounds=((-210, 0), (-190, 2*np.pi)))
    phas.append(abs(aopt[1]-mopt[1])/np.pi)

ax2.plot(rad, ampl, label="Max Amplitude Response")
ax2.plot(rad, rms, label="RMS Amplitude Response")
ax2.set_title("Response Function")
ax2.set_xlabel("$\omega$ / $rad^{-1}$")
ax2.set_ylabel("Amplitude / rad")

# second set of axes for the phase response plot
ax2alt = ax2.twinx()
ax2alt.plot(rad, phas, label="Phase Response (axis right)",color="g")
ax2alt.set_ylabel("Phase / rad")
ax2alt.set_ylim(bottom=0)
ax2alt.yaxis.set_major_formatter(tck.FormatStrFormatter('%g $\pi$'))
ax2alt.yaxis.set_major_locator(tck.MultipleLocator(base=0.25))
fig2.legend()
fig.tight_layout()
fig2.tight_layout()
plt.show()
